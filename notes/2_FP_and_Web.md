# 왜 FP일까? 스스로 생각해보기
다시 정리해보겠습니다. 웹이 너무 복잡해졌고 많은 기능들이 부수효과를 일으켜 예측 블가능합니다. 하지만 문제가 있는 것이 아니라 꼭 필요한 기능입니다. 개발자 입장에선 예측 불가하기 때문에 불편함과 불안함이 있을 뿐이죠. 그래도 무언가 제어를 할 필요성이 느껴집니다.

A라는 함수가 있다고 가정해보겠습니다. A는 계산만 하는 코드 100줄을 가지고 있지만 단 1줄이 랜덤 숫자를 생성하여 랜덤한 값을 생성하고 그 값을 이용해 결과를 반환합니다. 'A함수는 부수효과를 가진 액션이다'에서 끝이 나는 것이 아닙니다. 만약 A가 함수 B에서 호출이 된다면 B도 액션이 되는 것이고, A가 구조의 최하층에 있다면 모든 상위 함수들이 액션이 될 수 있습니다. 

그렇다면 이 액션을 순수하게 만들 수 있는지 먼저 생각해보아야 할 것 같습니다. '랜덤 숫자 생성' 자체를 예측 가능하게 바꿀 수 있을까요? 예측이 가능한 랜덤은 존재할 수 없습니다고 생각합니다. 

액션 자체를 없애는 건 불가능하니, 액션의 영역을 줄이는 방향을 생각해보겠습니다. 액션과 계산(순수기능)을 `기능적`인 분류가 먼저 필요합니다. 그리고 액션으로 인해 계산이 순수성을 오염받지 않도록 `구조적`으로 분리가 필요합니다. 액션이 계산을 호출하는 건 문제가 없지만, 계산이 액션을 사용하는 것을 최소화해야 하므로 꼭 액션이어야 하는 부분은 경계에 두어야 할 것 같습니다. 

고민해 본 결과 액션을 한 곳에 몰아 두거나 경계에 두게 되면 `불필요한 부수효과를 줄이고`, `액션을 제어`할 수 있는 효과를 얻게 됩니다. 함수형 패러다임이 웹의 존재하는 액션을 마법처럼 없애주는 건 아니지만 분리를 통해 어디에서 액션이 일어나는 지 구조화하여 명확하게 제어할 수 있기 때문에 유용한 도구라는 생각이 들었습니다.

# 왜, 그리고 어떻게 FP가 웹 기술에 사용될까
## React

React는 완전한 “함수형 프레임워크”라고 부르기에는 애매하지만, 함수형 아이디어를 강하게 끌어온 도구라고 느껴집니다. 특히 `불변 데이터`, `순수 함수에 가까운 컴포넌트`, `합성(composition)`측면에서 그 흔적을 찾아보겠습니다.

### 불변 데이터

React 공식 문서에서는 상태를 다룰 때 `불변으로 취급하라`고 강조합니다. 객체나 배열을 직접 바꾸기보다는, 기존 값을 복사한 뒤 변경된 새 값을 만들어 `useState/setState`로 교체하는 방식을 권장하여 액션이 발생하지 않도록 합니다. 

react를 사용해보았다면 아마 이런 코드를 자연스럽게 작성해봤을 것입니다.

```jsx
setTodos(prev => [...prev, newTodo]);
setItems(prev => prev.filter(item => item.id !== id));
```
중요한 건 useState 자체가 불변성을 자동으로 보장해 주는 것은 아닙니다. 다만 React는 이전 상태와 새로운 상태를 비교해서 렌더링 여부를 결정하기 때문에, 상태를 불변 데이터처럼 다루는 쪽이 React의 동작 방식과 가장 잘 맞습니다.
그래서 배열이나 객체를 직접 수정하는 것이 아닌, map, filter, 전개 연산자(...)로 새로운 값을 만들어 setState에 넘기는 방식이 상태를 다룰 때 중요합니다. (이러한 내장 메소드의 특징을 보며 모든 것엔 만들어진 의도가 담겨 있음이 느껴집니다.....)

불변성을 가지면 다음과 같은 장점이 생깁니다.
- 상태 흐름을 추적
  이전 상태와 다음 상태가 명확히 나뉘기 때문에 '어디서 무엇이 바뀌었는지'를 비교하고 디버깅하기가 수월합니다. 
- 리렌더링 최적화
  참조가 바뀌었는지만 비교해서(`===`) 변경 여부를 쉽게 확인할 수 있습니다.

결국 “상태를 불변 데이터처럼 다룬다”는 것은 FP의 불변성을 웹 UI에 적용한 예라고 볼 수 있습니다.

### 순수 함수

React에서 컴포넌트를 구현할 때 클래스가 아닌 함수를 추천하며, 컴포넌트가 항상 같은 입력(props, state, context등)에 대해 같은 결과(JSX)를 반환하는 순수함수라고 가정합니다.

물론 실제로 UI 컴포넌트가 완전히 순수할 수 는 없습니다. useEffect로 네트워크 요청을 보내거나 전역 상태를 읽어올 수 도 있습니다. 그럼에도 렌더링을 최대한 순수하게(같은 입력->같은 결과) 만들고 부수효과는 useEffect와 같은 명시적 자리에 몰아 넣는 함수형 패러다임의 모습을 보여주고 있습니다.

## Redux
redux는 상태 관리를 위한 라이브러리 입니다. 다양한 대체제가 있지만 fp에 대해 많은 걸 배울 수 있습니다. redux가 동작하는 구조을 먼저 살펴보겠습니다.

1. store를 만들어서 데이터를 넣고, view는 해당 store를 구독합니다.(publish-subscribe 패턴이 연상되네요!)
2. view가 action을 dispatch해서 상태 변경 요청을 보냅니다.
3. reducer가 액션의 타입에 따라 state를 변경한다.
4. 새 state를 반환하고, 그에 따라 view를 갱신한다.

즉, store에 상태를 모으고, action → reducer → state → view로 이어지는 흐름을 가지는 구조라고 이해할 수 있습니다. 내부적으로는 store에 대한 subscribe를 통해 publish–subscribe 패턴처럼 동작하지만, 전체적으로 보면 단방향 데이터 플로우라고 이해했습니다.

Redux의 핵심 API를 보면 함수형 설계에 대해 더 분명해집니다. Redux가 클래스를 전혀 사용하지 않고 순수 함수와 클로저만으로 설계되어 있습니다.
- createStore()
  - 현재 상태와 리스너 배열을 클로저로 만듭니다.
  - 그리고 외부에는 getState, dispatch, subscribe만 반환합니다.
  - dispatch(action)은 reducer를 호출해서 새 상태를 계산한 뒤, 구독자에게 전달합니다.
  - 상태 변경 로직은 순수한 reducer를 안에만 존재합니다.
  => “입력(state, action) → 출력(nextState)” 형태의 순수 함수를 중심에 두는 구조!!
- combineReducers()
  - 여러 reducer들을 받아서 하나의 큰 reducer로 합성합니다.
  => 쪼개진 순수 함수들을 하나의 큰 순수함수로 묶어 합성

정리하면, Redux는

- 상태를 store라는 한곳에 모으고,
- 상태 변경은 순수한 reducer에서만 일어나게 강하게 제한하며,
- 부수효과는 미들웨어나 구독자 쪽으로 밀어내는 구조를
- 함수와 데이터의 조합만으로 구현한 라이브러리

라고 이해했습니다.

## 웹에서 FP의 역할
여기까지 정리하며 느낀 Fp의 역할과 효과에 대해서 이야기해보겠습니다. 비유해보자면 웹의 `액션에 대한 strict mode`를 켜 주는 것과 같다고 느꼈습니다. (처음에는 액션을 없애준다고 오해했지만) 아무 곳에서나 액션을 쓰지 못하게 하고, 써야 한다면 어디서 쓰는지 구조를 통해 드러내도록 만들 수 있기 떄문입니다.

1. 액션, 계산, 데이터의 경계를 확실히 한다.
- 본질적으로 웹은 액션을 가득차 있고 fp는 분리를 통해 계산, 액션, 데이터를 의식하게 합니다.
- 그리고 액션을 경계 쪽으로 밀어내도록 설계할 수 있습니다.
2. 상태, 상태 변경, 렌더링을 더욱 예측 가능하게 만든다.
- fp에 기반한 구조(불변 상태, 순수에 가까운 컴포넌트, redux)으로 인한 순수성 덕분에 상태 흐름을 추적하기 쉬워질 뿐 아니라 버그 추적도 쉬워집니다.
3. 테스트가 용이합니다.
- 이번 미션 뿐 아니라 지난 3가지 미션을 하면서 가장 직접적으로 느낀 부분입니다. fp를 적용하면 핵심 로직은 순수함수로 구현이 되기 때문에 테스트가 편하며 추후 로직이 변경되더라도 부수효과에 대한 걱정이 없게 됩니다.

결론적으로 웹의 복잡성에 대응하기 위해서 '액션은 줄이고, 계산과 데이터를 중심에 두고, 액션을 경계로 몰아낸다'라는 코어 원칙을 다양한 도구들을 다양한 방법으로 적용하고 있다고 생각합니다. 