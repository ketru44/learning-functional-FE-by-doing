# 왜 FP일까? 스스로 생각해보기
다시 정리해보겠습니다. 웹이 너무 복잡해졌고 많은 기능들이 부수효과를 일으켜 예측 블가능합니다. 하지만 문제가 있는 것이 아니라 꼭 필요한 기능입니다. 개발자 입장에선 예측 불가하기 때문에 불편함과 불안함이 있을 뿐이죠. 그래도 무언가 제어를 할 필요성이 느껴집니다.

A라는 함수가 있다고 가정해보겠습니다. A는 계산만 하는 코드 100줄을 가지고 있지만 단 1줄이 랜덤 숫자를 생성하여 랜덤한 값을 생성하고 그 값을 이용해 결과를 반환합니다. 'A함수는 부수효과를 가진 액션이다'에서 끝이 나는 것이 아닙니다. 만약 A가 함수 B에서 호출이 된다면 B도 액션이 되는 것이고, A가 구조의 최하층에 있다면 모든 상위 함수들이 액션이 될 수 있습니다. 

그렇다면 이 액션을 순수하게 만들 수 있는지 먼저 생각해보아야 할 것 같습니다. '랜덤 숫자 생성' 자체를 예측 가능하게 바꿀 수 있을까요? 예측이 가능한 랜덤은 존재할 수 없습니다고 생각합니다. 

액션 자체를 없애는 건 불가능하니, 액션의 영역을 줄이는 방향을 생각해보겠습니다. 액션과 계산(순수기능)을 `기능적`인 분류가 먼저 필요합니다. 그리고 액션으로 인해 계산이 순수성을 오염받지 않도록 `구조적`으로 분리가 필요합니다. 액션이 계산을 호출하는 건 문제가 없지만, 계산이 액션을 사용하는 것을 최소화해야 하므로 꼭 액션이어야 하는 부분은 경계에 두어야 할 것 같습니다. 

고민해 본 결과 액션을 한 곳에 몰아 두거나 경계에 두게 되면 `불필요한 부수효과를 줄이고`, `액션을 제어`할 수 있는 효과를 얻게 됩니다. 함수형 패러다임이 웹의 존재하는 액션을 마법처럼 없애주는 건 아니지만 분리를 통해 어디에서 액션이 일어나는 지 구조화하여 명확하게 제어할 수 있기 때문에 유용한 도구라는 생각이 들었습니다.

# 왜, 그리고 어떻게 FP가 웹 기술에 들어왔을까
## React

React는 완전한 “함수형 프레임워크”라고 부르기에는 애매하지만, 함수형 아이디어를 강하게 끌어온 도구라고 느껴집니다. 특히 `불변 데이터`, `순수 함수에 가까운 컴포넌트`, `합성(composition)`측면에서 그 흔적을 찾아보겠습니다.

### 불변 데이터

React 공식 문서에서는 상태를 다룰 때 `불변으로 취급하라`고 강조합니다. 객체나 배열을 직접 바꾸기보다는, 기존 값을 복사한 뒤 변경된 새 값을 만들어 `useState/setState`로 교체하는 방식을 권장하여 액션이 발생하지 않도록 합니다. 

react를 사용해보았다면 아마 이런 코드를 자연스럽게 작성해봤을 것입니다.

```jsx
setTodos(prev => [...prev, newTodo]);
setItems(prev => prev.filter(item => item.id !== id));
```
중요한 건 useState 자체가 불변성을 자동으로 보장해 주는 것은 아닙니다. 다만 React는 이전 상태와 새로운 상태를 비교해서 렌더링 여부를 결정하기 때문에, 상태를 불변 데이터처럼 다루는 쪽이 React의 동작 방식과 가장 잘 맞습니다.
그래서 배열이나 객체를 직접 수정하는 것이 아닌, map, filter, 전개 연산자(...)로 새로운 값을 만들어 setState에 넘기는 방식이 상태를 다룰 때 중요합니다. (이러한 내장 메소드의 특징을 보며 모든 것엔 만들어진 의도가 담겨 있음이 느껴집니다.....)

불변성을 가지면 다음과 같은 장점이 생깁니다.
- 상태 흐름을 추적
  이전 상태와 다음 상태가 명확히 나뉘기 때문에 '어디서 무엇이 바뀌었는지'를 비교하고 디버깅하기가 수월합니다. 
- 리렌더링 최적화
  참조가 바뀌었는지만 비교해서(`===`) 변경 여부를 쉽게 확인할 수 있습니다.

결국 “상태를 불변 데이터처럼 다룬다”는 것은 FP의 불변성을 웹 UI에 적용한 예라고 볼 수 있습니다.

### 순수 함수

React에서 컴포넌트를 구현할 때 클래스가 아닌 함수를 추천하며, 컴포넌트가 항상 같은 입력(props, state, context등)에 대해 같은 결과(JSX)를 반환하는 순수함수라고 가정합니다.

물론 실제로 UI 컴포넌트가 완전히 순수할 수 는 없습니다. useEffect로 네트워크 요청을 보내거나 전역 상태를 읽어올 수 도 있습니다. 그럼에도 렌더링을 최대한 순수하게(같은 입력->같은 결과) 만들고 부수효과는 useEffect와 같은 명시적 자리에 몰아 넣는 함수형 패러다임의 모습을 보여주고 있습니다.
