#함수형 프로그래밍

중요한 건 “코드를 함수형으로 생각하는 힘인 함수형 사고 패러다임”

## 함수형 프로그래밍을 공부하고 알아야하는 이유가 무엇일까?

- 좋은 코드에 대한 정답은 없지만 적어도 `좋은 설계`를 가지고 있을  수록 좋은 코드가 될 수 있음
- 프로그램의 덩치가 작을 땐 체감하지 못함, 실제로 이 단계에서는 나쁜 코드가 생산성이 좋고 가독성이 좋을 수 있음
- 그러나 큰 크기를 가지게 되면 설계가 없는 코드에서는 생산성에 문제가 생긴다

⇒ 좋은 설계를 짜고 유지해야한다.

(유지? 코드 전반에 걸쳐 일관된 원칙과 규칙으로 작성되어야 한다는 말)

이러한 원칙과 규칙이 될 수 있는 것들 `패러다임` 이라고 한다.

ex) OOP : 객체를 중심으로 사고하고 프로그램을 작성하는 것

## 패러다임의 중요성을 알았어…. 그래서 함수형 프로그래밍(패러다임)이 무엇이고 왜 필요한데?

`데이터`를 `함수로 연결`하는 것을 중심으로 사고하고 프로그래밍하는 것이다. 

<aside>
💡

함수형 프로그래밍은 단순하게 그리고 간결하게 프로그램을 바라볼 수 있도록 도와줍니다.

</aside>

그러니까 함수형 패러다임이라는 관점을 가지면 프로그램을 간결하게 단순하게 바라볼 수 있게 됩니다.

(더 낫다는게 아님!!!)

## JS와 함수형 패러다임

js는 함수형 프로그래밍 기반 위에 객체 지향 언어의 껍데기를 씌운 패러다임의 언어입니다. 결국 객체지향에 함수형 프로그래밍을 섞으면 장점이 있다는 것을 보여주었고 멀티 패러다임의 근간이 됩니다. (함수형 패러다임 기반 + 객체 지향 문법)

그러므로 함수형 패러다임에 대한 이해는 JS에 대한 깊은 이해로 이어집니다. (현대 언어에 대한 이해!!)

js를 가장 설계 원칙에 맞춰 사용하기 위해서는 객체지향스럽게 작성을 하면서도 함수형 패러다임으로 개발

“몰랐네?” 할 수 있지만 이미 고차함수, 프로미스 등 대부분에 이 함수형 패러다임이 녹아 있기 때문에 낯설지는 않을 것이다.

# 함수형 프로그래밍 언어

## 0. 용어 재정의

함수형 프로그래밍 언어에서 순수함수, 불변성, 선언적 패턴이라는 3가지 요소가 굉장히 중요하다. 하지만 너무 이론적인 개념이기 때문에 실용적인 입장에서 다음과 같은 방식으로 재정의한다.

`순수함수` → 코드를 `액션`과 `계산`, `데이터` 로 분리하자. 특히 액션에서 계산을 분리하는 코드를 작성하자

`불변성`  → `카피온라이트` 와 `방어적복사` 를 이용하여 불변성을 유지한다.

`선언적 패턴` → `계층형 설계` 와 `추상화 벽` 을 이용하여 무엇과 어떻게를 구분하여 설계를 유지한다.(→좋은 코드)

## 1. 순수함수 → 액션,계산,데이터

### 1.1 액션, 계산, 데이터 정의

함수형 프로그래밍 언어에서는 순수함수로 프로그래밍을 하고 사이드 이펙트를 멀리하자고 말하지만, 이 사이드 이펙트가 우리가 작성하는 프로그램의 목적이 될 때가 많다. 

그래서 그 개념을 프로그램은 `액션`, `계산`, `데이터` 3가지로 나누어 프로그래밍하는 것이라고 재정의하면 결과적으로 함수형 패러다임의 방향성을 이해할 수 있다. 

- `액션 : 호출 시점과 실행 횟수에 의존`
  - 암묵적인 입력이나 출력을 가지고 있음
- `계산: 입력에서 출력으로의 연산`
  - 명시적인 입력과 출력만 존재
- `데이터: 이벤트들에 대한 사실을 기록한 것`

버튼을 클릭하면 숫자가 올라가는 카운터 프로그램을 예시로 들어주셔서 활용한다.

- 데이터: 숫자가 바로 데이터
- 액션: 버튼 클릭을 언제 하느냐 그리고 여러 번 할수록 다른 결과가 만들어지기 때문에 액션
- 계산: 기존 숫자에 1을 더해 새로운 숫자를 만들어내는 계산

### `액션`이 발생하면 미리 정의된 `계산`에 의해 `데이터`가 바뀌게 됨

이 프로그램을 함수형 프로그래밍 언어로 작성하면 다음과 같다

```jsx
function Counter {
	//데이터
	let cnt; // 불변성??? 더 학습해보자
	// 계산
	const increase = (value) => value + 1;
	// 액션
	const onClick = () => {cnt = increse(cnt)};
}
```

### 1.2 액션에서 계산을 분리하자!

- `계산`은 반드시 `입출력`을 가지고 `같은 입력`에 대해서는 항상 `같은 출력값`을 내놓아야 한다(수학적 함수의 정의와 일치)
- 함수형 프로그래밍의 핵심은 액션과 계산을 분리해서 `액션을 최소화`하고 `계산함수를 많이 만들어서 관리`를 하는 것이다.

### 1.3 액션함수를 계산함수로 변경하는 방법

계산함수를 만들기 위해서는 입출력을 가져야한다. 입출력을 생각하면 명시적인 인자와 리턴값만 생각하기 쉽지만, 암묵적인 입출력이 존재한다.(함수 외부 값 변경 등등)

하나의 함수에 이러한 암묵적인 입출력과 명시적 입출력이 섞여 있다면 계산이 아닌 `액션`으로 정의된다.

- 암묵적 입력은 인자에 추가해 명시적 입력으로 변경
- 암묵적 출력은 사용하지 않도록 제거

```jsx
const increase = (cnt, offset) => { // 계산 함수
	const result = cnt + offset
	return result // setState와 같은 암묵적 출력은 제거
}
```

이렇게 계산 함수를 만들고 나니 계산 함수는 명시적인 입출력을 가지며 어떠한 사이드 이펙트를 만들어내지 않는 걸 확인할 수 있다.(+같은 입력에 대해 같은 결과)

⇒ 계산은 순수함수였다~~~!

### 1.4 정리

- 프로그램은 액션에 의해 변하는 데이터로, 데이터가 변하는 방법은 따로 만든 독립적인 계산이다.
- 액션, 계산과 데이터를 함수로 연결하여 작성하는 개념이 함수형 패러다임이다.
- 실행시점과 실행횟수에 의존적인 액션에서 계산(순수함수)를 분리하여 복잡한 코드를 간단하게 만들어 테스트를 용이하도록 만들도록 한다.

## 2. 불변성 → 카피온라이트, 방어적 복사

계산 함수를 알아보면서 그 특징으로 같은 입력에 대해서 같은 출력을 가진다고 했었다. 

하지만 우리는 JS로 개발을 하면서 `pass by reference` 방식을 통하여 외부의 값들을 수정을 했던 경험이 있다. 그래서 객체나 배열을 `pass by value` 의 형태로 변경하여 수정하여도 원본이 변하지는 않게 하는 방식에 대해 고민해보아야 한다.

### 2.1 Copy on Write

```jsx
const increase = (arr) => {
	const value = arr[arr.length - 1]
	arr.push(value + 1);
	return arr
}
```

이 `increase` 함수는 계산이 아니라 액션이다. js에서 object나 array와 같은 큰 값을 다룰 때 (아마 메모리 효율을 위해서) `pass by reference`를 사용하기 때문에 위와 같은 방식으로는 원본 배열이 수정된다. 

그래서 함수형 프로그래밍을 할 때에는 array와 object 사용 시 주의해야한다. 당장 메모리는 효율적이어도 좋은 코드로 이어지기 위한 좋은 설계가 무너지게 된다.

그렇다면 어떻게 문제를 해결해야할까? ⇒ `Copy on Write(얕은복사)`

- 원본의 값을 복사해서 그 복사본을 수정한다면 계산함수의 제약을 준수할 수 있다.
- 이 방법을 통해 액션을 계산으로 만들 수 있다. (1과 이어지는 느낌)

```jsx
const increase = (arr) => {
	arr = arr.slice() // 복사해서 사용!!
------------------------
const setObjectName = (obj, value) => {
	return {
		...obj
		name: value
	}
}
```

????? 궁금증 이러면 어쩔 수 없이 메모리 문제가 발생할 것 같은데 어떻게 해결해야 할까?

### 2.2 방어적 복사

Copy on Write가 가능했던 이유는 우리가 수정할 수 있기 때문이다. 그러나 만약 우리가 수정할 수 가 없는 라이브러리라면 어떻게 해결해야할까? ⇒ `방어적 복사(깊은복사)`

```jsx
const someCaculation = (obj, value) => {
	const clone = structuredClone(obj); // 완전한 clone을 만들어내는 api
	someActionLibrary(clone, value);
	return clone;
}
```

중첩된 모든 구조를 복사하는 방식을 깊은 복사라고 한다. JS에 `structuredClone()` 이라는 기능이 있기 때문에 활용하면 된다.

### 2.3 정리

`Copy on Write`와 `방어적 복사`를 통해 `계산 함수`의 `불변성`을 유지할 수 있다.

## 3. 선언적 패턴과 계층형 구조

지금까지 내용을 정리하면 함수형 프로그래밍은 액션, 계산, 데이터로 구분하고 불변성을 이용해서 액션에서 최대한 계산을 분리하고자 했다. 이렇게 함수로 나누다보면 자연스럽게 `좋은 구조`를 만들 수 있다.

<aside>
💡

코드를 작게 분리하면 좋은점

1. 재사용
2. 유지보수
3. 테스트
</aside>

그리고 이러한 과정에서 자연스럽게 함수 간의 계층이 생긴다는 것을 알 수 있다.

### 3.1 계층적 구조

- 액션, 계산, 데이터로 코드를 구분하고 계층을 만들고, 계층을 고려하며 넘나들지 않는 코드를 짜다보면 자연스좋은 구조의 코드가 만들어진다.
- 계산 함수의 비중을 높이고, 계층을 넘나들지 않도록 코드를 쪼개다보면 이게 좋은 설계와 리팩토링에 대한 좋은 근거가 될 수 있다.

액션으로 갈 수록 코드의 형태는 당연히 무엇을 하는 것인지 행동을 기반한 기획서에 가까운 코드가 만들어지고, 심지어 데이터 구조를 몰라도되는 형태가 된다. 

계산과 데이터에 가까워 질 수록 데이터 중심적인 코드를 작성하게 되고 상대적으로 재사용성이 높고, 테스트하기 좋은 코드 형태를 갖추게 된다. 

⇒ 이런식으로 계층을 침범하지 않도록 코드를 작성하여 계층적인 차이가 발생하면 자연스럽게 `추상화벽` 이 생긱게 되어, 상단과 하단이 서로 영향을 주지 않도록 할 수 있다. (좋은 설계!)

### 4. 클로저

선언할 당시의 환경을 기억했다가 나중에 호출 시 원래의 환경에 따라 호출되는 함수(포섭)